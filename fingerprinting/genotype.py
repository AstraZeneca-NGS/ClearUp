import subprocess
from itertools import izip
from collections import defaultdict
from os.path import join, dirname
import sys
import vcf

from ngs_utils.sambamba import index_bam
from ngs_utils.call_process import run
from ngs_utils.utils import is_local, is_us
from ngs_utils.parallel import ParallelCfg, parallel_view
from ngs_utils.file_utils import file_transaction, safe_mkdir, chdir, which, adjust_path, can_reuse, add_suffix, \
    verify_file
from ngs_utils.logger import info, err, critical, debug

from ngs_reporting.bcbio.bcbio import BcbioProject

import az


DEPTH_CUTOFF = 5


def genotype_bcbio_dir(bcbio_dir, snp_file, sys_cfg, parallel_cfg, depth_cutoff=DEPTH_CUTOFF):
    info('Loading bcbio project from ' + bcbio_dir)
    info('-' * 70)
    proj = BcbioProject()
    proj.load_from_bcbio_dir(bcbio_dir, proc_name='fingerprinting', need_coverage_interval=False)
    safe_mkdir(proj.work_dir)
    info('Loaded ' + proj.final_dir)
    bam_files = [s.bam for s in proj.samples]
    debug('Found BAM files: ' + str(bam_files))

    genome_cfg = az.get_refdata(proj.genome_build)

    info('** Running VarDict ** ')
    vcf_by_sample = _run_vardict_pileup(proj, proj.work_dir, snp_file, parallel_cfg, genome_cfg)
    info('** Finished running VarDict **')

    fingerpints_dir = safe_mkdir(join(proj.date_dir, 'fingerprints'))
    fasta_by_sample = {s.name: join(fingerpints_dir, s.name + '.fasta') for s in proj.samples}
    for s in proj.samples:
        info('Writing Fasta for sample ' + s.name)
        vcf_to_fasta(s, vcf_by_sample[s.name], fasta_by_sample[s.name], depth_cutoff)

    info('Merging Fasta')
    all_fasta = join(fingerpints_dir, 'longprints.fasta')
    if not can_reuse(all_fasta, fasta_by_sample.values()):
        with open(all_fasta, 'w') as out_f:
            for s in proj.samples:
                with open(fasta_by_sample[s.name]) as f:
                    out_f.write(f.read())
    info('All fasta saved to ' + all_fasta)
    return all_fasta, vcf_by_sample


def _run_vardict_pileup(proj, work_dir, snp_file, parallel_cfg, genome_cfg):
    with parallel_view(len(proj.samples), parallel_cfg, safe_mkdir(work_dir)) as view:
        vcfs = view.run(_vardict_pileup_one_sample, [[s, work_dir, genome_cfg, view.cores_per_job, snp_file] for s in proj.samples])
    return dict(zip([s.name for s in proj.samples], vcfs))


def _vardict_pileup_one_sample(sample, work_dir, genome_cfg, threads, snp_file):
    sample_work_dir = safe_mkdir(join(work_dir, sample.name))
    vardict_snp_vars_vcf = join(sample_work_dir, 'vardict_snp_vars.vcf')

    if not can_reuse(vardict_snp_vars_vcf, [sample.bam, snp_file]):
        if is_local():
            vardict_dir = '/Users/vlad/vagrant/VarDict/'
        elif is_us():
            vardict_dir = '/group/cancer_informatics/tools_resources/NGS/bin/'
        else:
            vardict_pl = which('vardict.pl')
            if not vardict_pl:
                critical('Error: vardict.pl is not in PATH')
            vardict_dir = dirname(vardict_pl)

        index_bam(sample.bam)

        vardict = join(vardict_dir, 'vardict.pl')
        test_strandbias = join(vardict_dir, 'teststrandbias.R')
        var2vcf_valid = join(vardict_dir, 'var2vcf_valid.pl')

        ref_file = adjust_path(genome_cfg['seq'])
        cmdl = ('{vardict} -G {ref_file} -N {sample.name} -b {sample.bam} -p -D {snp_file}'
                ' | cut -f-34'
                ' | {test_strandbias}'
                ' | {var2vcf_valid}'
                ' | grep "^#\|TYPE=SNV\|TYPE=REF" '
                ).format(**locals())
        run(cmdl, output_fpath=vardict_snp_vars_vcf)

    return _fix_vcf(vardict_snp_vars_vcf)


def _fix_vcf(vardict_snp_vars_vcf):
    """ Fixes VCF generated by VarDict in puleup debug mode:
        - Fix non-call records with empty REF and LAT, and "NA" values assigned to INFO's SN and HICOV
    :param vardict_snp_vars_vcf: VarDict's VCF in pileup debug mode
    """
    vardict_snp_vars_fixed_vcf = add_suffix(vardict_snp_vars_vcf, 'fixed')
    info('Fixing VCF, writing to ' + vardict_snp_vars_fixed_vcf)
    with open(vardict_snp_vars_vcf) as inp, open(vardict_snp_vars_fixed_vcf, 'w') as out:
        for l in inp:
            if not l.startswith('#'):
                fs = l.split('\t')
                chrom, start, ref, alt, filt = fs[0], fs[1], fs[3], fs[4], fs[6]
                # samtools = which('samtools')
                # if not samtools:
                #     sys.exit('Error: samtools not in PATH')
                # cmdl = '{samtools} faidx {ref_file} {chrom}:{start}-{start}'.format(**locals())
                # out = subprocess.check_output(cmdl, shell=True)
                # fasta_ref = out.split('\n')[1].strip().upper()
                # if ref:
                #     assert ref == fasta_ref, ref + '   ' + fasta_ref + '   ' + l
                if ref in ['.', '']:
                    # assert alt == '', l  # ALT is empty too
                    fs[3] = '.'
                    fs[4] = '.'
                    l = '\t'.join(fs)
                    l = l.replace('=NA;', '=.;')
                    l = l.replace('=;', '=.;')
            out.write(l)
    return vardict_snp_vars_fixed_vcf


def __p(rec):
    s = rec.samples[0]
    gt_type = {
        0: 'hom_ref',
        1: 'het',
        2: 'hom_alt',
        None: 'uncalled'
    }.get(s.gt_type)
    gt_bases = s.gt_bases
    return str(rec) + ' FILTER=' + str(rec.FILTER) + ' gt_bases=' + str(gt_bases) + ' gt_type=' + gt_type + ' GT=' + str(s['GT']) + ' Depth=' + str(s['VD']) + '/' + str(s['DP'])


def vcfrec_to_seq(rec, is_male, depth_cutoff):
    var = rec.samples[0]

    depth_failed = var['DP'] < depth_cutoff
    filter_failed = any(v in ['MSI12', 'InGap'] for v in rec.FILTER)
    if depth_failed or filter_failed:
        var.called = False

    if var.called:
        gt_bases = ''.join(sorted(var.gt_bases.split('/')))
    else:
        gt_bases = 'NN'

    if rec.CHROM == 'chrY' or rec.CHROM == 'chrX' and is_male:  # a single chromosome
        assert not var.is_het, str(rec) + ' | ' + __p(rec)
        gt_bases = gt_bases[0]

    return gt_bases


def check_if_male(recs):
    y_total_depth = 0
    for rec in recs:
        depth = rec.INFO['DP']
        if 'Y' in rec.CHROM:
            y_total_depth += depth
    return y_total_depth >= 5


def vcf_to_fasta(sample, vcf_file, fasta_file, depth_cutoff):
    if can_reuse(fasta_file, vcf_file):
        return fasta_file

    info('Parsing VCF ' + vcf_file)
    with open(vcf_file) as f:
        vcf_reader = vcf.Reader(f)
        recs = [r for r in vcf_reader]

    is_male = check_if_male(recs)
    with open(fasta_file, 'w') as fhw:
        fhw.write('>' + sample.name + '\n')
        fhw.write(''.join(vcfrec_to_seq(rec, is_male, depth_cutoff) for rec in recs) + '\n')

    info('Fasta saved to ' + fasta_file)
